% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Mehr zu Funktionen}
\date{9. Dezember 2021}

\begin{document}
	
\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}

\section*{Gesamtübersicht}
\begin{frame}{Gesamtübersicht}
	\textbf{Themen der nächsten Stunden}
	\begin{itemize}
		\item Referenzen Erklärung
		\item  Klassen
		\item Imports
		\item Nützliche Funktionen zur Iteration
		\item \alert{Lambda}
		\item \alert{Unpacking}
		\item File handeling
		\item Listcomprehension
		\item Dekoratoren
	\end{itemize}
\end{frame}

\section{Wiederholung}
\begin{frame}{Wiederholung}
	\textbf{Beim letzten Mal:}
	\begin{itemize}
		\item Vererbung
		\lstinputlisting[firstline=9,lastline=10]{resources/06_inheritance_modules/inherit.py}
		\item Module Einführung
		\lstinputlisting[firstline=0,lastline=2]{resources/06_inheritance_modules/modules.py}
	\end{itemize}	
\end{frame}

\section{Unpacking}

\begin{frame}{Was ist Unpacking?}
	Unpacking, bzw. Packing, bezeichnet eine Operation, mit der man Elemente eines \codeline{iterables} direkt an Variablen binden kann. Wir kennen das bereits von Tupeln:
	\lstinputlisting[firstline=1,lastline=5]{resources//08_unpacking_lambda/unpacking.py}
	Das funktioniert mit jedem \codeline{iterable}, also auch mit Listen zum Beispiel.
\end{frame}

\begin{frame}{Der *-Operator}
	Der *-Operator gestattet das Zusammenfassen mehrerer Werte in einer einzigen Variable:
	\lstinputlisting[firstline=7,lastline=8]{resources//08_unpacking_lambda/unpacking.py}
	Auch wenn nach der Variable (hier \codeline{a}) nichts mehr folgt, muss trotzdem das Komma gesetzt werden.
\end{frame}

\begin{frame}{Der *-Operator}
	Man kann den *-Operator auch zusammen mit dem herkömmlichen Packing/Unpacking verbinden. Python ermittelt selbst, welche Variable welche Werte bekommen muss:
	\lstinputlisting[firstline=10,lastline=17]{resources//08_unpacking_lambda/unpacking.py}
	\begin{description}
		\item[Achtung] In so einem Ausdruck darf der *-Operator höchstens einmal vorkommen.
	\end{description}
\end{frame}

\begin{frame}{Der *-Operator}
	Man kann Unpacking auch in Verbindung mit Funktionen benutzen:
	\lstinputlisting[firstline=19,lastline=23]{resources//08_unpacking_lambda/unpacking.py}
	oder anders herum:
	\lstinputlisting[firstline=25,lastline=29]{resources//08_unpacking_lambda/unpacking.py}
\end{frame}

\begin{frame}{Der *-Operator}
	oder zusammen:
	\lstinputlisting[firstline=31,lastline=35]{resources//08_unpacking_lambda/unpacking.py}
	Hier wird das Tupel ausgepackt, sodass alle Elemente einzeln in die Funktion gegeben werden. Effektiv verhält es sich also wie in Beispiel 1.
\end{frame}

\begin{frame}{Der **-Operator}
	Der **-Operator ist das Unpacking-Equivalent für Dictionarys. Dieser ist vor allem für Funktionen interessant, denn durch ihn kann man das Unpacking mit Keyword-Argumenten verbinden:
	\lstinputlisting[firstline=37,lastline=41]{resources//08_unpacking_lambda/unpacking.py}
	oder zusammen mit dem *-Operator:
	\lstinputlisting[firstline=43,lastline=49]{resources//08_unpacking_lambda/unpacking.py}
\end{frame}



\section{Lamdba}

\begin{frame}{Funktionen als Objekte}
	Funktionen können als Objekte behandelt werden, also z.B. als Argument in einer weiteren funktion angenommen werden.
	\lstinputlisting[firstline=3,lastline=5]{resources//08_unpacking_lambda/funktionen.py}
	\lstinputlisting[firstline=17,lastline=18]{resources//08_unpacking_lambda/funktionen.py}
	Die Klammern machen dabei den Unterschied, ob das Funktions Objekt gemeint ist oder der Wert, den die Funktion zurück gibt.
\end{frame}

\begin{frame}{Funktionen als Objekte}
	Beispiel einer Funktion, die eine weitere Funktion \codeline{action} als Argument entgegen nimmt und ausführt. (und die Zeit der Ausführung ausgibt) 
	\lstinputlisting[firstline=0,lastline=15]{resources//08_unpacking_lambda/funktionen.py}
\end{frame}
\begin{frame}{Lambda Funktionen}
	Eine Lambda Funktion startet mit dem keyword \codeline{lambda}. Es folgen mit Komma getrennte Argumente, dann ein Doppelpunkt. Danach folgt was ausgegeben werden soll.
	\lstinputlisting[firstline=0,lastline=15]{resources//08_unpacking_lambda/lamda_syntax.py}
\end{frame}{Lambda Funktionen}

\begin{frame}{Lambda Funktionen}
	\codeline{lambda} Funktionen verhalten sich wie gewöhnliche Funktionen, nur das sie in einer Zeile definiert werden können und damit keinen Namen brauchen. Desshalb nennt man sie auch \alert{anonyme Funktionen}.
	\lstinputlisting[firstline=0,lastline=10]{resources//08_unpacking_lambda/lambda.py}
\end{frame}{Lambda Funktionen}

\end{document}
