% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Mutation und Klassen}
\date{18. November 2021}

\begin{document}
	
\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}

\section{Wiederholung}
\begin{frame}{Wiederholung}
	
\end{frame}

\section{Gesamtübersicht}
\begin{frame}{Gesamtübersicht}
	\textbf{Themen der nächsten Stunden}
	\begin{itemize}
		\item Pointer Erklärung
		\item Klassen
		\item Imports
		\item Nützlich funktionen zur Iteration
		\item Lambda
		\item File handeling
		\item Listcomphrehension
		\item Unpacking
		\item Dekoratoren
	\end{itemize}
\end{frame}

\section{Referenzen und Mutation}
\begin{frame}{Referenzen}
	Python benutzt ein Konzept namens \alert{"Call by Object-Reference"}. 
	
	Alle Objekte, die in einem Programm auftauchen, liegen im Arbeitsspeicher. Variablen dienen dann dazu, um diesen Objekten einen Namen, eine sogenannte \alert{Referenz} zu geben. 
	
	Variablen sind also nicht ihre Objekte selber, sondern bloß Bezeichner für diese.
\end{frame}

\begin{frame}{Referenzen}
	\lstinputlisting[firstline=1,lastline=2]{resources/05mutation_klassen/reference.py}
	Führt man diesen Code aus, so legt Python den String 'Hallo Welt' irgendwo in den Arbeitsspeicher. 
	
	Die Variable \codeline{hallo} ist nun die Referenz. Greift man auf sie zu, so folgt Python der Referenz in den Arbeitsspeicher und liest dort das eigentliche Objekt aus.
\end{frame}

\begin{frame}{Referenzen}
	Ein Objekt kann auch mehrere Bezeichner haben.
	\lstinputlisting[firstline=4,lastline=5]{resources/05mutation_klassen/reference.py}
	Hier ist \codeline{a} der Name für eine Liste. In Zeile 2 wird nun nicht die Liste kopiert, sondern nur die Referenz darauf. \codeline{b} ist also nur ein weiterer Bezeichner für \textit{dieselbe} Liste.
	
	Dieser Sachverhalt wird deutlich, wenn wir versuchen, \codeline{b} zu verändern:
	\lstinputlisting[firstline=7,lastline=7]{resources/05mutation_klassen/reference.py}
	Python folgt \codeline{b} bis zu der Liste und fügt eine \texttt{2} an. Da \codeline{a} immer noch eine Referenz auf dieselbe Liste hat, wird die Veränderung auch ersichtlich, wenn wir uns \codeline{a} statt \codeline{b} anschauen.
\end{frame}

\section{Klassen und Objekte}
\begin{frame}{Klassen und Objekte}
	Menschen denken in Objekten, denen Eigenschaften und Funktionen zugeordet werden. \linebreak
	\begin{center}
		 \textbf{Ein Rennwagen ist schnell, und die Kuh macht "muh".} \linebreak
	\end{center}
	Deswegen eignet sich dieses Konzept gut um Code intuitiv zu strukturieren.
\end{frame}
\begin{frame}{bekannte Beispiele}
	Listen: \codeline{liste.append('element')}
	\linebreak
	Dictionaries: \codeline{dictionary.keys()}
	\linebreak
	
	Die \codeline{keys()}-Funktion ist Teil des Dictionary Objekts. Eine Liste z.B. hat keine \codeline{keys()}-Funktion. 
	\linebreak\linebreak
	\codeline{liste.keys()} wird fehlschlagen.	
\end{frame}

\begin{frame}
	Mit dem Punkt \codeline{.} kann auf die Funktionen des Objekts und Attribute zugegriffen werden.
	\lstinputlisting[firstline=13,lastline=13]{resources/05mutation_klassen/einleitung_klassen.py}
	Mit den Klammern wird angezeigt, dass man eine Funktion des Objekts ausführen will.
	\lstinputlisting[firstline=14,lastline=14]{resources/05mutation_klassen/einleitung_klassen.py}
	\begin{center}
		\Large Funktion eines Objekts $\,\to\,$ \alert{Methode}
	\end{center}
\end{frame}
\begin{frame}{Klassen / Objekte selbst definieren}
	Um ein Objekt zu erhalten, muss zunächst eine Klasse definiert werden. Anschließend muss diese Klasse ausgeführt (instanziiert) werden. Die \codeline{\_\_init\_\_} Funktion wird jedesmal aufgerufen, wenn eine neue Instanz der Klasse erzeugt wird (Konstruktor).
	\lstinputlisting[firstline=0,lastline=5]{resources/05mutation_klassen/einleitung_klassen.py}
	\lstinputlisting[firstline=13,lastline=13]{resources/05mutation_klassen/einleitung_klassen.py}
\end{frame}
\begin{frame}{self}
	In jeder Methode einer Klasse wird \codeline{self} als Eingabe mitgegeben. \codeline{self} repräsentiert eine Referenz zu dem jeweiligen Objekt, dass die Methode aufgerufen hat.\linebreak
	In der \codeline{\_\_init\_\_} Methode kann \codeline{self} benutzt werden um die Attribute jeder Instanz der Klasse zu setzen. (Zeile 3)
	\lstinputlisting[firstline=0,lastline=5]{resources/05mutation_klassen/einleitung_klassen.py}
	\lstinputlisting[firstline=13,lastline=13]{resources/05mutation_klassen/einleitung_klassen.py}
\end{frame}
\begin{frame}{Methoden}
	Methoden können nach dem gleichen Schema angelegt werden wie Funktionen, mit zwei Unterschieden.
	\begin{itemize}
		\item methoden enthalten mindestens \codeline{self} als Eingabe-Argument
		\lstinputlisting[firstline=7,lastline=7]{resources/05mutation_klassen/einleitung_klassen.py}
		\item methoden werden unter Klassen definiert
		\lstinputlisting[firstline=6,lastline=7]{resources/05mutation_klassen/einleitung_klassen.py}
	
	\end{itemize}
\end{frame}
\begin{frame}{Magische Methoden}
	Es gibt einige Methodennamen die in Klassen reserviert sind. Alle starten und enden mit doppelten Unterstrich. Diese Methoden heißen auch "magic methods", weil sie spezifische Dinge, scheinbar magisch, automatisch passieren lassen:
	 \begin{center}
	 	\codeline{\_\_*f\_name*\_\_} \linebreak\linebreak
	 	\pause
	 	\begin{tabular}{m{2.5cm} | m{6cm}}
	 		Methodenname & Zweck \\ \hline\hline
	 		\codeline{\_\_init\_\_} & Konstruktor: wird bei Objekt() aufgerufen \\ \hline
	 		\codeline{\_\_str\_\_} & bestimmt Rückgabewert von str(Objekt) \\
	 		\hline
	 		\codeline{\_\_add\_\_} & bestimmt Rückgamewert Objekt + Objekt \\
	 	\end{tabular}
	 \end{center} 
\end{frame}


\section*{Beispiel}
\begin{frame}{Beispiel}
	\textbf{Problemmodellierung:}
	Pokemon
	\begin{itemize}
		\item Eigenschaften
		\begin{itemize}
			\item Name
			\item maximale HP (Health Points)
			\item aktuelle HP
			\item Angriffs Kraft
		\end{itemize}
		\item Aktionen / Funktionen
		\begin{itemize}
			\item angegriffen werden
			\item anderes Pokemon angreifen
			\item geheilt werden
		\end{itemize}
	\end{itemize}
	zu beachten:
	\begin{itemize}
		\item HP sollen nicht unter 0 sinken
		\item Pokemon mit 0 HP können nicht angreifen
	\end{itemize}

\end{frame}
\end{document}
