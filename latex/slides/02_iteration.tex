% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Zahlen, Listen und Schleifen}
\date{28. Oktober 2021}

\usepackage{graphicx}

\begin{document}
	
\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}


\section{Wiederholung}
\begin{frame}{Wiederholung}
	\textbf{Beim letzten Mal}:
	\begin{itemize}
		
		
		\item
		der Python Interpreter
		\item
		"Hallo Welt" mit der \alert{\texttt{print()}} Funktion 
		\item Interaktion mit dem Terminal mit \alert{\texttt{input()}}
		\item
		string Formatierung mit f-Strings
		\lstinputlisting[firstline=22,lastline=22]{resources/01_getting_started/string_format.py}
		\item \alert{\texttt{if / else / elif}} statements
		\item string methoden z.B. \alert{\texttt{isnumeric(), isupper()}}
		
		
	\end{itemize}
\end{frame}
% Problemfolie
\begin{frame}{Wiederholung}
	\begin{itemize}
		\item Navigation mir dem Terminal in das richtige directory
		\begin{figure}
			\includegraphics[width=\linewidth]{resources/02iteration/commandlinepython.png}
		\end{figure}
		
		\item
		starten eines Python-Scripts
		\lstinputlisting[firstline=0,lastline=2]{resources/02iteration/python.txt}
		\item
		IndentationError: tritt z.B. auf, wenn Tabs und Leerzeichen nicht konsistent benutzt werden, oder bei flaschen Einrückungen
		\lstinputlisting[lastline=4]{resources/02iteration/bad_indentation.py}
		
	\end{itemize}
\end{frame}

\section{Zahlen}
\begin{frame}{Zahlen}
	\textbf{Die zwei Typen}
	\linebreak
	
	Python kennt zwei verschiedene Zahlentypen: 
	\begin{itemize}
		\item \alert{\texttt{int}} (Integer/Ganzzahl)
		\lstinputlisting[firstline=0,lastline=2]{resources/02iteration/numbers.py}
		\item \alert{\texttt{float}} (floating point number/Gleitkommazahl)
		\lstinputlisting[firstline=4,lastline=5]{resources/02iteration/numbers.py}
	\end{itemize}		
\end{frame}

\begin{frame}{Zahlen}
	\textbf{Mathematische Operationen}
	\linebreak

	Auf allen Zahlen sind verschiedene mathematische Operationen möglich:
	\lstinputlisting[firstline=7,lastline=12]{resources/02iteration/numbers.py}
	\begin{description}
		\item[\textbf{Achtung:}] Das Ergebnis wird bei der Division automatisch zu einem \alert{\texttt{float}} konvertiert, selbst dann, wenn es keinen Rest gibt.
	\end{description}
\end{frame}

\begin{frame}{Zahlen}
	Man kann auch bestehende Variablen einfach mit einem Ergebnis überschreiben, ohne eine neue Variable anlegen zu müssen:
	\lstinputlisting[firstline=14,lastline=16]{resources/02iteration/numbers.py}
	Dafür bietet Python eine Abkürzung:
	\lstinputlisting[firstline=18,lastline=21]{resources/02iteration/numbers.py}
\end{frame}

\begin{frame}{Zahlen}
	\textbf{Vergleichsoperationen}
	\linebreak
	
	Es sind mehrere Vergleichsoperationen möglich. Jede dieser Operationen resultiert in einem \alert{\texttt{bool}}:		
	\lstinputlisting[firstline=23,lastline=28]{resources/02iteration/numbers.py}
	Alle Ausdrücke in diesem Beispiel nehmen den Wert \alert{\texttt{True}} an.
\end{frame}

\section{Listen}
\begin{frame}{Listen - Initialisierung}
	Listen sind eine Datenstruktur vom Typ \alert{\texttt{list}}, eine geordnete Sammlung von Elementen.
	\lstinputlisting[firstline=0,lastline=6]{resources/02iteration/list.py}
	Indexierung startet in Python mit 0.
	\lstinputlisting[firstline=8,lastline=13]{resources/02iteration/list.py}
\end{frame}
\begin{frame}{Listen - append/remove}
	Listen bieten Funktionen zur einfachen Veränderung
	\lstinputlisting[firstline=2,lastline=2]{resources/02iteration/list.py}
	\lstinputlisting[firstline=15,lastline=18]{resources/02iteration/list.py}
	\lstinputlisting[firstline=19,lastline=21]{resources/02iteration/list.py}
	\lstinputlisting[firstline=23,lastline=26]{resources/02iteration/list.py}
\end{frame}

\section{for in Schleife}
\begin{frame}{for in Schleife}
	Die \alert{\texttt{for}}-Schleife wird genutzt, um über eine Sequenz zu iterieren, z.B. Listen oder Strings. Dabei definiert sie eine Variable, die nach jeder Iteration den Wert des nächsten Elementes annimmt:
	\lstinputlisting[firstline=5,lastline=8]{resources/02iteration/for_loop.py}
	\lstinputlisting[firstline=10,lastline=13]{resources/02iteration/for_loop.py}
	Die Schleife bricht automatisch ab, wenn es kein nächstes Element mehr gibt.
\end{frame}

\begin{frame}{for in Schleife}
	Die \alert{\texttt{range()}}-Funktion gibt eine Sequenz aus Zahlen zurück. Grundsätzlich gibt sie, bei der Eingabe \textit{n}, die Zahlen 0 bis \textit{n}-1 zurück. In diesem Beispiel also würde die Variable \alert{\texttt{i}} nacheinander die Werte 0 bis 999 annehmen:
	\lstinputlisting[firstline=0,lastline=3]{resources/02iteration/for_loop.py}
	\begin{description}
		\item[\textbf{Achtung:}] Die durch die \alert{\texttt{for}}-Schleife definierte Variable bleibt auch nach Beendigung der Schleife noch erhalten. Sie besitzt dann den Wert, den sie nach der letzten Iteration hatte (hier also 999).
	\end{description}
\end{frame}

\section{while Schleife}
	\begin{frame}{while Schleife}
		Die \alert{\texttt{while}}-Schleife prüft vor jeder Iteration, ob eine gegebene Bedingung den Wert \alert{\texttt{True}} besitzt:
		\lstinputlisting[firstline=0,lastline=2]{resources/02iteration/while_loop.py}
		Die Schleife bricht erst ab, wenn die Bedingung den Wert \alert{\texttt{False}} annimmt:
		\lstinputlisting[firstline=4,lastline=9]{resources/02iteration/while_loop.py}
	\end{frame}
	
	\begin{frame}{while Schleife}
	Die Bedingung muss während der Schleifenausführung verändert werden, sonst ist die Schleife endlos:
	\lstinputlisting[firstline=11,lastline=13]{resources/02iteration/while_loop.py}
	Man kann das \alert{\texttt{break}}-Statement verwenden, um die Schleife auch unabhängig der Bedingung zu unterbrechen (geht auch bei der \alert{\texttt{for}}-Schleife):
	\lstinputlisting[firstline=14,lastline=18]{resources/02iteration/while_loop.py}
	\end{frame}
\end{document}
