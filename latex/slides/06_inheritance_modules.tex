% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Vererbung und Module}
\date{25. November 2021}

\begin{document}
	
\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}

\section*{Gesamtübersicht}
\begin{frame}{Gesamtübersicht}
	\textbf{Themen der nächsten Stunden}
	\begin{itemize}
		\item Referenzen Erklärung
		\item  \alert{Klassen}
		\item \alert{Imports}
		\item Nützliche Funktionen zur Iteration
		\item Lambda
		\item File handeling
		\item Listcomprehension
		\item Unpacking
		\item Dekoratoren
	\end{itemize}
\end{frame}

\section{Wiederholung}
\begin{frame}{Wiederholung}
	\textbf{Beim letzten Mal:}
	\begin{itemize}
		\item Referenzen
		\item Klassen 
		\lstinputlisting[firstline=0,lastline=3]{resources/05mutation_klassen/einleitung_klassen.py}
	\end{itemize}	
\end{frame}

\section{Vererbung}
\begin{frame}{Vererbung - Konzept}
	\begin{itemize}
		\item Vererbung ermöglicht das weitergeben von Eigenschaften und Funktionen einer Klasse an eine andere.
		\item Die Klasse, die von einer anderen erbt wird auch als \alert{KindKlasse} oder auch \alert{SubKlasse} bezeichnet, die von der geerbt wird als \alert{ElternKlasse} oder auch \alert{SuperKlasse}
		\item KindKlassen übernehmen die Funktionalität ihrere Eltern
		\item KindKlassen können wie ihre Eltern behandelt werden, ElternKlassen nicht wie ihre Kinder *
	\end{itemize}
	* Alle Daumen sind Finger, aber nicht alle Finger Daumen.
\end{frame}

\begin{frame}{Vererbung}
	Folgende Klasse ist gegeben:
	\lstinputlisting[firstline=0,lastline=7]{resources/06_inheritance_modules/inherit.py}
	Es kann eine neue Klasse definiert werden, die von \codeline{Baum} erbt:
	\lstinputlisting[firstline=9,lastline=10]{resources/06_inheritance_modules/inherit.py}
\end{frame}

\begin{frame}{Vererbung}
	\lstinputlisting[firstline=9,lastline=10]{resources/06_inheritance_modules/inherit.py}
	Die neue Klasse \codeline{NadelBaum} verhält sich zunächst genau wie \codeline{Baum}.
	\lstinputlisting[firstline=12,lastline=15]{resources/06_inheritance_modules/inherit.py}
	Dieses Verhalten ermöglicht, dass zukünftig alle Instanzen der NadelBaum Klasse auch als Instanz der Baum Klasse behandelt werden können.
\end{frame}

\begin{frame}{Vererbung - Erweiterung}
	Um Verhalten zu erweitern können:
	\begin{itemize}
		\item bestehende Methoden überschrieben werden
		\item neue Methoden angelegt werden
		\item bestehende Attribute verändert werden
		\item neue Attribute angelegt werden
	\end{itemize}
	Wenn eine Methode überschrieben wird, kann mit der \codeline{super()} Funktion
	auf die Methoden und Attribute der ElternKlasse zugegriffen werden.
	\lstinputlisting[firstline=21,lastline=22]{resources/06_inheritance_modules/inherit.py}
\end{frame}

\begin{frame}{Vererbung}
	Um das Verhalten von Funktionen zu verändern können sie überschrieben werden.
	\lstinputlisting[firstline=16,lastline=16]{resources/06_inheritance_modules/inherit.py}
	\lstinputlisting[firstline=21,lastline=23]{resources/06_inheritance_modules/inherit.py}
	Um neue Attribute einzufügen, kann der Konstruktor, die \codeline{\_\_init\_\_} methode überschrieben werden.
	\lstinputlisting[firstline=17,lastline=19]{resources/06_inheritance_modules/inherit.py}
\end{frame}

\begin{frame}{Polymorphismus - Polymorphism}
	Vererbung erlaubt es Objekte die der gleichen Super-Klasse angehören, gleich zu behandeln, auch wenn sie möglicherweise verschiedenen Sub-Klassen angehören.\linebreak
	\textbf{Beispiel:}
	\lstinputlisting[firstline=0,lastline=19]{resources/06_inheritance_modules/poly.py}
\end{frame}

\section{Module - Einführung}
\begin{frame}{Module}
	Module sind Dateien, die Python-Ausdrücke und Definitionen enthalten. 
	
	Sie enden immer mit \alert{.py}. Diese Dateien kennen wir schon, nämlich als normale Scripte. Das Besondere ist jedoch, dass man diese Module als Objekt in sein eigentliches Script einbinden und nutzen kann.
	
\end{frame}

\begin{frame}{Import}
	Über das \codeline{import}-Statement kann man Module in sein Script einfügen. Es gibt zwei Möglichkeiten, dieses Statement zu verwenden.
	
	 Im Folgenden gehen wir davon aus, dass sich das ausgeführte Script im selben Verzeichnis wie die Datei \texttt{mein\_modul.py} befindet. In der Datei \texttt{mein\_modul.py} soll es eine Klasse namens \texttt{ImportiereMich} geben.
	 \pause
	
	\textbf{Möglichkeit 1:}
		\lstinputlisting[firstline=0,lastline=2]{resources/06_inheritance_modules/modules.py}
		\pause
	\textbf{Möglichkeit 2:}
		\lstinputlisting[firstline=4,lastline=5]{resources/06_inheritance_modules/modules.py}
	
\end{frame}

\begin{frame}{Import}
	Nutzt man bei diesem Beispiel Möglichkeit 1, so verhält sich das Modul wie ein normales Objekt.
	\lstinputlisting[firstline=0,lastline=2]{resources/06_inheritance_modules/modules.py}
	Mit dem \codeline{.} kann man auf Attribute und Methoden zugreifen, was hier nun Funktionen, Klassen und Variablen sind.
	
\end{frame}
\end{document}
