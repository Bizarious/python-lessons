% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Module und Erweiterte Iteration}
\date{2. Dezember 2021}

\begin{document}
	
\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}

\section*{Gesamtübersicht}
\begin{frame}{Gesamtübersicht}
	\textbf{Themen der nächsten Stunden}
	\begin{itemize}
		\item Referenzen Erklärung
		\item  Klassen
		\item \alert{Imports}
		\item \alert{Nützliche Funktionen zur Iteration}
		\item Lambda
		\item File handeling
		\item Listcomprehension
		\item Unpacking
		\item Dekoratoren
	\end{itemize}
\end{frame}

\section{Wiederholung}
\begin{frame}{Wiederholung}
	\textbf{Beim letzten Mal:}
	\centering\begin{itemize}
		\item Referenzen
		\item Klassen 
		\lstinputlisting[firstline=0,lastline=3]{resources/05mutation_klassen/einleitung_klassen.py}
	\end{itemize}

		
\end{frame}

\section{Module}
\begin{frame}{Grundlegendes}
	Erinnerung an Importe:
	\lstinputlisting[firstline=1,lastline=2]{resources//07imports_iteration/imp.py}
	oder:
	\lstinputlisting[firstline=4,lastline=5]{resources//07imports_iteration/imp.py}
	Importe funktionieren aus dem selben und aus niedrigeren Verzeichnissen ohne Probleme. Will man etwas aus einem höheren Verzeichniss importieren, so wird deutlich mehr Konfigurationsaufwand benötigt. Moderne IDEs nehmen das allerdings ab.	
\end{frame}

\begin{frame}{\_\_name\_\_ == '\_\_main\_\_'}
	Importiert man ein Modul, so wird jeder Code sofort ausgeführt, der nicht in Funktionen oder Klassen verpackt ist.
	
	Um das zu verhindern, gibt es ein 'Protection Statement':
	\lstinputlisting[firstline=7,lastline=8]{resources//07imports_iteration/imp.py}
	Die \codeline{\_\_name\_\_}-Variable nimmt nur den Wert \codeline{'\_\_main\_\_'} an, wenn das Modul direkt ausgeführt wird. 
	
	Wird es nur importiert, so hat die Variable einen anderen Wert. Dadurch wird das, was durch die \codeline{if}-Abfrage geschützt wird, nicht ausgeführt.
\end{frame}

\begin{frame}{Standardbibliothek}
	Die Standardbibliothek ist eine Sammlung von Modulen, die bereits nach der Installation von Python vorhanden ist.
	
	\textbf{Zwei Beispiele}
	
	\codeline{time:}
	\lstinputlisting[firstline=10,lastline=12]{resources//07imports_iteration/imp.py}
	\codeline{random:}
	\lstinputlisting[firstline=14,lastline=16]{resources//07imports_iteration/imp.py}
	In der \alert{\href{https://docs.python.org/3/library/}{Doku}} findet man alle verfügbaren Module.
\end{frame}

\section{Nützliche Funktionen zur Iteration}
\begin{frame}{enumerate}
	Nimmt eine Liste entgegen und gibt sie als Tupelliste mit den jeweiligen Positionen in der Liste aus.
	\begin{itemize}
		\centering\item[Eingabe:] \codeline{['A', 'B', 'C', 'D']}
		\centering\item[Ausgabe:] \codeline{[(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]}
	\end{itemize}
\end{frame}
\begin{frame}{enumerate}
	Durch die Liste von Tupeln kann normal (tupelweise) iteriert werden.
	\lstinputlisting[firstline=0,lastline=1]{resources//07imports_iteration/iteration.py}
	\lstinputlisting[firstline=9,lastline=12]{resources//07imports_iteration/iteration.py}
	Aber auch indem man den Elementen der jeweiligen Tupel direkt namen zuweist.
	\lstinputlisting[firstline=3,lastline=6]{resources//07imports_iteration/iteration.py}
\end{frame}

\begin{frame}{zip}
	Nimmt zwei (oder mehr) Listen entgegen und gibt sie als Tupelliste zurück, wobei Elemente an gleicher Position in der Liste in einem Tupel zusammengefasst werden.
	\begin{itemize}
		\centering\item[Eingabe:] \codeline{['A', 'B', 'C', 'D'], ['a', 'b', 'c', 'd']}
		\centering\item[Ausgabe:] \codeline{[('A', 'a'), ('B', 'b'), ('C', 'c'), ('D', 'd')]}
	\end{itemize}
	\textbf{Hinweis:} Die Ausgabeliste ist immer so lang wie die kürzeste eingegebene Liste. Elemente von längeren Listen werden ignoriert.
\end{frame}
\begin{frame}{zip}
	Wie bei enumerate kann durch die tuple,
	\lstinputlisting[firstline=15,lastline=16]{resources//07imports_iteration/iteration.py}
	\lstinputlisting[firstline=23,lastline=26]{resources//07imports_iteration/iteration.py}
	oder direkt durch die Elemente iteriert werden.
	\lstinputlisting[firstline=17,lastline=20]{resources//07imports_iteration/iteration.py}
\end{frame}
\begin{frame}{zip}
	\textbf{Beispiel mit mehr als zwei Listen:}
	\lstinputlisting[firstline=30,lastline=36]{resources//07imports_iteration/iteration.py}
\end{frame}

\end{document}
